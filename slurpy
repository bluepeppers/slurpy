#!/usr/bin/env python
#
# slurpy - AUR search/download/update helper
#
# Randy Morris <randy@rsontech.net>
#
# depends:
#           python
#
# optdepends: 
#           python-cjson -  speeds up processing significantly on operations
#                           with many results
#           python-pycurl - enable uploading packages to the AUR
#
#
# Credits: This code started off as a port of the original arson ruby code
#          written by Colin Shea.  It has since changed very much, but the
#          roots are still obvious.
#
#          Colin's project can be found at <http://evaryont.github.com/arson>
#
# CREATED:  2008-08-22 18:41
# MODIFIED: 2009-08-28 08:10

import glob
import os
import re
import sys
import urllib

from getpass import getpass
from distutils import version as Version
from optparse import OptionParser
from cStringIO import StringIO
from tarfile import TarFile

try:
    import cjson as Json
except ImportError:
    import json as Json

try:
    import pycurl
except ImportError:
    __doc__ = """Usage: slurpy [options] <operation> PACKAGE [PACKAGE2..]

 Operations:
  -d, --download          download PACKAGE(s)
                             if passed twice will also download dependencies
                             from the AUR
  -i, --info              show info for PACKAGE(s)
  -s, --search            search for PACKAGE(s)
  -u, --update            check explicitly installed packages for available
                          updates
                             if passed with --download flag(s), perform download
                             operation for each package with an available update

 General options:
  -c, --color             use colored output
  -f, --force             overwrite existing files when dowloading
  -q, --quiet             show only package names in search/update results
  -t DIR, --save-to=DIR   target directory where files will be downloaded
  -v, --verbose           show info messages
                             if passed twice will also show debug messages

  -h, --help              show this message
      --version           show version information"""
else:
    __doc__ = """Usage: slurpy [options] [--sync] <operation> PACKAGE [PACKAGE2..] 
       slurpy [options] --push FILE1 [FILE2..] 


 Modes:
  -S, --sync              Retrieve package(s)/info from the AUR (DEFAULT)
  -P, --push              Upload a package to the AUR

 Sync Operations:              
  -d, --download          download PACKAGE(s)
                             if passed twice will also download dependencies
                             from the AUR
  -i, --info              show info for PACKAGE(s)
  -s, --search            search for PACKAGE(s)
  -u, --update            check explicitly installed packages for available
                          updates 
                             if passed with --download flag(s), perform download
                             operation for each package with an available update

 Push Options:
  -C, --category          package category in the AUR
                             New Package DEFAULT: none
                             Update DEFAULT: current category in the AUR
  -U, --user              AUR username

 General options:
  -c, --color             use colored output
  -f, --force             overwrite existing files when dowloading
  -q, --quiet             show only package names in search/update results
  -t DIR, --save-to=DIR   target directory where files will be downloaded
  -v, --verbose           show info messages
                             if passed twice will also show debug messages

  -h, --help              show this message
      --version           show version information"""

# utility functions
def json_decode(url):
    """Open <url> and decode the json response"""
    try: 
        return Json.decode(urllib.urlopen(url).read())
    except AttributeError:
        return Json.loads(urllib.urlopen(url).read())

def strip_slashes(str):
    """Remove extraneous backslashes (\) from <str>"""
    if str is None:
        return "None"
    return re.sub(r"\\(.)", r"\1", str.encode('UTF-8'))

# class definitions
class Slurpy():
    
    """Main Slurpy class"""

    COLOR_CONF = "/etc/pacman.d/color.conf"
    AUR_URL = "http://aur.archlinux.org"

    def __init__(self, opts):
        """Sets up colors and sets opts for the class"""
        self.opts = opts

        # default colors to be used if COLOR_CONF is not readable
        self.colors = {"red":"boldred", "green":"boldgreen",
                       "yellow":"boldyellow", "blue":"boldblue",
                       "magenta":"boldmagenta", "cyan":"boldcyan",
                       "white":"boldwhite"}

        # read COLOR_CONF to get pacman-color's settings
        if self.opts.color:
            try:
                file = open(self.COLOR_CONF, 'r')
                conf = file.read()
                file.close()
                for color in self.colors:
                    col = re.findall("^\s*"+color.capitalize()+".*", conf, re.M) 
                    if len(col):
                        col = col[0].split('=')[1].strip()
                        col = re.sub("intensive\s*", "bold", col)
                        self.colors[color] = col
            except IOError:
                self.write_ln("Error reading color.conf, using default colors",
                              type="debug")
            

    def colorfy(self, string, col):
        """Returns <string> with the ansi escape codes wrapping the string"""
        colors = {"black":      "0",  "gray":           "9",
                  "red":        "1",  "boldred":        "10",
                  "green":      "2",  "boldgreen":      "11",
                  "yellow":     "3",  "boldyellow":     "12",
                  "blue":       "4",  "boldblue":       "13",
                  "magenta":    "5",  "boldmagenta":    "14",
                  "cyan":       "6",  "boldcyan":       "15",
                  "white":      "7",  "boldwhite":      "16",
                  "foreground": "8",  "boldforeground": "17"}

        if not self.opts.color or col not in colors:
            return string
        elif self.colors[col][:4] == "bold":
            col = self.colors[col][4:]
            return "\033[1;3" + colors[col] + "m" + string + "\033[1;m"
        else:
            return "\033[3" + colors[self.colors[col]] + "m" + string + \
                    "\033[1;m"

    def write(self, *args, **kwargs):
        """print wrapper: provides an easy way to print colors and templates

        optional kwargs: color = one of the following colors:
                                 red, green, yellow, blue, magenta, cyan, white

                         type = templates defined as follows:
                            "info",    prepends white "info: " to str
                            "debug",   prepends blue "debug: " to str
                            "warning", prepends yellow "warning: " to str
                            "error",   prepends red "error: " to str
        """

        string = ' '.join(args)

        for arg in ['color', 'type']:
            if arg not in kwargs:
                kwargs[arg] = False

        if kwargs['color']:
            string = self.colorfy(string, kwargs['color'])

        if kwargs['type'] == "error":
            string = self.colorfy("error: ", "red") + string
        elif kwargs['type'] == "warning":
            string = self.colorfy("warning: ", "yellow") + string
        elif kwargs['type'] == "info":
            string = self.colorfy("info: ", "magenta") + string
            if self.opts.verbose > 0:
                sys.stdout.write(string)
            return
        elif kwargs['type'] == "debug":
            string = self.colorfy("debug: ", "cyan") + string
            if self.opts.verbose > 1:
                sys.stdout.write(string)
            return

        sys.stdout.write(string)

    def write_ln(self, *args, **kwargs):
        """print wrapper: calls self.write() and appends a newline if anything
        was actually written (due to verbosity level)"""
        args = list(args) + ['\n']
        self.write(*args, **kwargs)

class AURSync(Slurpy):

    """ Handles all pull requests from the AUR """

    PACMAN_CACHE = "/var/lib/pacman/local"
    PACMAN_CONF = "/etc/pacman.conf"
    PACMAN_REPOS = ['core', 'extra', 'community']
    PACMAN_SYNC = "/var/lib/pacman/sync/"

    INFO_URL = "http://aur.archlinux.org/rpc.php?type=info&arg="
    SEARCH_URL = "http://aur.archlinux.org/rpc.php?type=search&arg="

    # json constants
    ID = "ID"
    NAME = "Name"
    VERSION = "Version"
    CATEGORY = "CategoryID"
    DESCRIPTION = "Description"
    LOCATION = "LocationID"
    URL = "URL"
    PATH = "URLPath"
    LICENSE = "License"
    VOTES = "NumVotes"
    OUT_OF_DATE = "OutOfDate"
    CATEGORIES = [None, None, "daemons", "devel", "editors", "emulators",
                  "games", "gnome", "i18n", "kde", "lib", "modules",
                  "multimedia", "network", "office", "science", "system",
                  "x11", "xfce", "kernels"]


    def __init__(self, opts, args):

        Slurpy.__init__(self, opts)

        self.args = []
        
        # encode white space
        for arg in args:
            self.args.append(urllib.quote(arg))

        # enable testing repo if enabled on the machine
        try:
            file = open(self.PACMAN_CONF, 'r')
            conf = file.read()
            file.close()
        except IOError:
            self.write_ln("Error reading pacman.conf, testing repo will"
                          "remain disabled", type="info")

        if re.search('^\s*\[testing\]', conf, re.M):
            self.PACMAN_REPOS = ['testing'] + self.PACMAN_REPOS
            self.write_ln("Testing repo enabled", type="debug")

    def display_result(self, pkgs, deps):
        """Print a nicely formated result of <pkgs> and <deps>"""
        if pkgs:
            if len(pkgs) == 1 and not deps:
                self.write(pkgs[0], color="white")
                self.write(" downloaded to ")
                self.write_ln(os.getcwd(), color="green")
            else:
                self.write("Packages downloaded to ")
                self.write(os.getcwd(), color="green")
                self.write_ln(":")
                for pkg in pkgs:
                    self.write_ln("   ", pkg, color="white")
        if deps:
            if len(deps) == 1 and not pkgs:
                self.write(deps[0], color="white")
                self.write(" is available in ")
                self.write_ln("pacman repos", color="yellow")
            else:
                self.write("\nDependencies found in ")
                self.write("pacman repos", color="yellow")
                self.write_ln(":")
                for dep in deps:
                    self.write_ln("   ", dep, color="white")

    def download(self, ignore=[]):
        """Downloads all packages in <self.args>
        
        Returns any (make)dependencies of that package found in the PKGBUILD.
        """
        dledpkgs = [] # holds list of downloaded pkgs
        repodeps = [] # holds list of dependencies available in pacman repos
        for arg in self.args:
            if arg in ignore: 
                continue

            if self.in_sync_db(arg) != False:
                repodeps.append(arg)
                continue

            json = json_decode(self.INFO_URL + arg)

            if json['type'] == 'error':
                self.write_ln(arg, json['results'], type="error")
                return(dledpkgs, repodeps)

            pkg = json['results']
            url = self.AUR_URL + strip_slashes(pkg[self.PATH])
            c_url = self.AUR_URL + '/packages/' + arg + '/' + arg + '.tar.gz'
            if url != c_url:
                self.write_ln("There might be a problem with this package in "
                              "the AUR's database.", type="info")
                self.write_ln("Using constructed url instead.", type="info")
                url = c_url

            fname = url.split('/')[-1].split('.tar.gz')[0]
            if not self.opts.force:
                if os.path.exists(fname + '.tar.gz'):
                    self.write_ln(os.getcwd() + "/" + fname + ".tar.gz exists.",
                                  type="error")
                    self.write_ln("Pass -f to force this operation.")
                    sys.exit()

                if os.path.exists(fname):
                    self.write_ln(os.getcwd() + "/" + fname, "exists.",
                                  type="error")
                    self.write_ln("Pass -f to force this operation.")
                    sys.exit()

            # download .tar.gz
            file = open(fname + '.tar.gz', 'w')
            file.write(urllib.urlopen(url).read())
            file.close()

            # unzip -- per aur guidelines, all fnames must be .tar.gz'd
            try:
                file = TarFile.open(fname + '.tar.gz', 'r:gz')
                file.extractall()
                file.close()
            except: 
                self.write_ln("Error extracting archive %s.tar.gz" % fname,  
                               type="error")
                os.unlink(fname + '.tar.gz')
                sys.exit()

            os.unlink(fname + '.tar.gz')
            dledpkgs.append(fname)
            
            # download deps
            if self.opts.download > 1:
                file = open(fname + '/PKGBUILD', 'r')
                pkgb = file.read()
                file.close()

                deps = []
                deptup = re.findall('[^(opt)](make)?depends=\((.*?)\)', 
                                    pkgb, re.S)
                for group in deptup:
                    for dep in group[1].split():
                        dep = re.findall('(.[^<>=]*).*', dep)[0].strip("'")
                        deps.append(dep)

                # download dependencies, but ignore already downloaded pkgs
                pkgs, deps = AURSync(self.opts, deps).download(dledpkgs)

                if pkgs != []:
                    dledpkgs.extend(pkgs)
                if deps != []:
                    repodeps.extend(deps)

        # remove dups
        repodeps = list(set(repodeps))
        repodeps.sort()
        dledpkgs.sort()

        return dledpkgs, repodeps

    def in_sync_db(self, name): 
        """Checks if <name> exists in the local syncdb for <repo>

        Returns true if found, otherwise false
        """
        for repo in self.PACMAN_REPOS:
            syncd = self.PACMAN_SYNC + repo
            if glob.glob(syncd + "/" + name + "-*"):
                return repo
        return False

    def info(self):
        """Prints all known info about each package in <self.args>"""
        for arg in self.args:
            json = json_decode(self.INFO_URL + arg)
            if json['type'] == 'error':
                self.write_ln(json['results'], type="error")
                sys.exit()
            pkg = json['results']

            if pkg[self.OUT_OF_DATE] == '0':
                out_of_date = "No"
            else:
                out_of_date = "Yes"

            self.write("Repository      : ")
            self.write_ln("aur", color="magenta")
            self.write("Name            : ")
            self.write_ln(pkg[self.NAME], color="white")
            self.write("Version         : ")
            if out_of_date == "Yes":
                self.write_ln(pkg[self.VERSION], color="red")
            else:
                self.write_ln(pkg[self.VERSION], color="green")
            self.write("URL             : ")
            self.write_ln(strip_slashes(pkg[self.URL]), color="cyan")
            self.write("Category        : ")
            self.write_ln(self.CATEGORIES[int(pkg[self.CATEGORY])])
            self.write("Licenses        : ")
            self.write_ln(strip_slashes(pkg[self.LICENSE]))
            self.write("Number of Votes : ")
            self.write_ln(pkg[self.VOTES])
            self.write("Out of Date     : ")
            if out_of_date == "Yes":
                self.write_ln(out_of_date, color="red")
            else:
                self.write_ln(out_of_date, color="green")
            self.write("Description     : ")
            self.write_ln(strip_slashes(pkg[self.DESCRIPTION]), "\n")

    def run(self):
        """Main processing for AURSync.

        Handles all function dispatching and pre/post result output.
        """
        if self.opts.update and self.opts.download:
            updates = [] # holds all available updates

            try:
                if self.opts.target_dir is not None:
                    os.chdir(self.opts.target_dir)
            except OSError:
                self.write_ln("Target dir does not exist or is not a"
                              "directory", type="error")
                sys.exit()

            for pkg, version in self.update():
                updates.append(pkg) 

            if updates == []:
                self.write_ln("No updates available")
                return

            self.args = updates
            self.write_ln("Downloading updates...", type="info")

            self.display_result(*self.download())

        elif self.opts.download:
            try:
                if self.opts.target_dir is not None:
                    os.chdir(self.opts.target_dir)
            except OSError:
                self.write_ln("Target dir does not exist or is not a"
                              "directory", type="error")
                sys.exit()

            self.display_result(*self.download())

        elif self.opts.info:
            self.info()
        elif self.opts.search:
            self.search()
        elif self.opts.update:
            for pkg, version in self.update():
                if self.opts.quiet:
                    self.write_ln(pkg)
                elif not self.opts.download:
                    self.write(pkg, color="white")
                    self.write_ln(" " + version, color="green")
        else:
            self.write_ln(__doc__)

    def search(self):
        """Search the AUR for <self.args> and print results to the screen"""
        pkgs = []
        for arg in self.args:
            json = json_decode(self.SEARCH_URL + arg)
            if json['type'] == 'error':
                if json['results'].lower() != "no results found":
                    self.write_ln(json['results'], type="error")
            else:
                pkgs.extend(json['results'])

        if pkgs == []:
            return

        # sort
        spkgs = sorted(pkgs, key=lambda k: k[self.NAME])

        # remove dups -- note: extra list traversal, but imo it's worth it
        i = 0
        for pkg in spkgs:
            if pkg == spkgs[i]: 
                continue
            i += 1
            spkgs[i] = pkg
        del spkgs[i+1:]

        for pkg in spkgs:
            if self.opts.quiet:
                self.write_ln(pkg[self.NAME], color="white")
            else:
                self.write("aur", color="magenta")
                self.write("/")
                self.write(pkg[self.NAME], color="white")
                if pkg[self.OUT_OF_DATE] == '0':
                    self.write_ln(" " + pkg[self.VERSION], color="green")
                else:
                    self.write_ln(" " + pkg[self.VERSION], color="red")

                self.write_ln("   ", strip_slashes(pkg[self.DESCRIPTION]))

    def update(self):
        """Checks all explicitly installed packages for updates in the AUR"""
        updates = []

        if not self.opts.quiet:
            self.write_ln("Checking for package updates... ", type="info")

        file = os.popen("pacman -Qm")
        for ln in file.readlines():
            name, version = ln[:-1].split(' ')
            pkg = json_decode(self.INFO_URL + name)['results']
            if pkg != "No result found":
                if self.update_available(pkg['Name'], pkg['Version']):
                    updates.append((name, pkg['Version']))

        return updates

    def update_available(self, name, version):
        """Helper for update(): does version comparison logic 
        
        Returns true if a new version is available, otherwise false
        """
        # We have to do some funky shit in here because of scm version 
        # numbering.

        # if the specific package/version is in the cache, there must not be an
        # update
        if os.path.exists(self.PACMAN_CACHE + "/" + name + "-" + version):
            return False
        else:
            glb = glob.glob(self.PACMAN_CACHE + "/" + name + "-*")

            # FIXME: wtf's the deal here?  Why a constant 1?  Could this
            # possibly return more than one?
            if len(glb) == 1: 
                pkg_name = os.path.basename(glb[0])
                
                # r_scm is a regex to match source control management package
                # version numbers
                r_scm = re.compile('-[0-9]{8}-[0-9]+$')

                # r_pkg is a regex to match any normal package version number
                r_pkg = re.compile(name + '-.+-[0-9]+$')

                if r_scm.search(pkg_name):
                    scm_installed = True
                elif r_pkg.search(pkg_name):
                    scm_installed = False
                else:
                    self.write_ln("Failed to detect pkg version type. ",
                                  "please contact my developer with the ",
                                  "below info.", type="error")
                    self.write_ln("pkg_name:", name, pkg_name)
                    self.write_ln("pkg_version:", version)
                    sys.exit()
                
                if r_scm.search(name + "-" + version):
                    scm_passed = True
                elif r_pkg.search(name+ "-" + version):
                    scm_passed = False

                if scm_passed and scm_installed:
                    passed_ver = \
                        r_scm.search(name + "-" + version).group().split("-")
                    inst_ver = r_scm.search(pkg_name).group().split("-")

                    # scm version numbers are always YYYYMMDD-REL
                    if passed_ver[1] > inst_ver[1]\
                         or (passed_ver[1] == inst_ver[1]\
                         and passed_ver[2] > inst_ver[2]):
                        return True
                    else:
                        return False
                else:
                    # compare LooseVersions of normal version numbers
                    inst_ver = r_pkg.search(pkg_name).group()[len(name)+1:]
                    inst_ver = Version.LooseVersion(inst_ver)
                    passed_ver = Version.LooseVersion(version)
                    if passed_ver > inst_ver:
                        return True
                    else:
                        return False

class AURPush(Slurpy):
    
    """ Handles all push requests to the AUR """

    AUR_SUBMIT_URL = "http://aur.archlinux.org/pkgsubmit.php"

    def __init__(self, opts, args):
        Slurpy.__init__(self, opts)

        self.args = args
        self.buffer = StringIO()
        self.cookiefile = os.environ['HOME'] + "/.slurpy.aurcookie"

        self.curl = pycurl.Curl()
        self.curl.setopt(pycurl.HTTPHEADER, ["Expect:"])
        self.curl.setopt(pycurl.COOKIEJAR, self.cookiefile)
        self.curl.setopt(pycurl.WRITEFUNCTION, self.buffer.write)
        self.curl.setopt(pycurl.FOLLOWLOCATION, 1)

    def __del__(self):
        """ Clean up curl and cookie file """
        self.curl.close()
        if os.path.exists(self.cookiefile):
            os.unlink(self.cookiefile)

    def login(self):
        """ Log in to the AUR web interface with self.opts.user,
        prompt for password.
        """
        self.opts.password = getpass('Password: ')
        data = [
            ('user', self.opts.user),
            ('passwd', self.opts.password)]

        self.curl.setopt(pycurl.HTTPPOST, data)
        self.curl.setopt(pycurl.URL, self.AUR_URL)
        self.curl.perform()
        
        # Bad username or password
        if self.buffer.getvalue().find("Bad username or password") != -1:
            self.write_ln("Bad username or password. Please try again.", 
                          type="error")
            sys.exit()

    def run(self):
        """ Main processing for AURPush """
        if opts.category is not None:
            if opts.category not in AURSync.CATEGORIES:
                self.write_ln("Category does not exist, please enter one of "
                              "the following categories:", type="error")
                for cat in AURSync.CATEGORIES[2:]:
                    self.write_ln(cat)

                sys.exit()

        self.login()
        self.upload()

    def upload(self):
        """ Upload files in self.args to the aur """

        for arg in self.args:
            if not os.path.isfile(arg):
                self.write(arg, "does not exist or is not a file.",
                           type="error")
                sys.exit()

            data = [
                ('pkgsubmit', '1'),
                ('category', '%s' % AURSync.CATEGORIES.index(self.opts.category)),
                ('pfile', (pycurl.FORM_FILE, arg))]

            self.curl.setopt(pycurl.HTTPPOST, data)
            self.curl.setopt(pycurl.URL, self.AUR_SUBMIT_URL)

            self.buffer.truncate(0)
            try:
                self.curl.perform()
            except:
                self.write_ln("Something is wrong with the selected file.", 
                              type="error")
                self.write_ln("If it is a .tar.gz file, try rebuilding it.")

            if self.buffer.getvalue().find("not allowed to overwrite") != -1:
                self.write(self.opts.user, color="white", type="error")
                self.write_ln(" does not own this package and can not "
                              "overwrite these files.")
            elif self.buffer.getvalue().find("Unknown file format") != -1:
                self.write_ln("Incorrect file format. Upload must conform to "
                              "AUR packaging guidelines.", type="error")

            idx = self.buffer.getvalue().find("<span class='f2'>")
            if idx != -1:
                pkg = self.buffer.getvalue()[17+idx:]

                idx = pkg.find("</span>")
                if idx != -1:
                    pkg = pkg[:idx]
                    
                    if pkg is not None:
                        self.write(pkg, color="white")
                        self.write_ln(" has been uploaded.")
            

# main processing 
if __name__ == '__main__':

    parser = OptionParser(version="%prog 2.5.0", conflict_handler="resolve")
    parser.add_option('-d', '--download', action='count')
    parser.add_option('-c', '--color', action='store_true')
    parser.add_option('-f', '--force', action='store_true')
    parser.add_option('-h', '--help', action='store_true')
    parser.add_option('-i', '--info', action='store_true')
    parser.add_option('-q', '--quiet', action='store_true')
    parser.add_option('-s', '--search', action='store_true')
    parser.add_option('-t', '--save-to', dest='target_dir', action='store') 
    parser.add_option('-u', '--update', action='store_true')
    parser.add_option('-v', '--verbose', action='count')

    if 'pycurl' in sys.modules:
        parser.add_option('-C', '--category', action='store', default=None)
        parser.add_option('-P', '--push', action='store_true', default=False)
        parser.add_option('-S', '--sync', action='store_true', default=True)
        parser.add_option('-U', '--user', action='store')

    opts, args = parser.parse_args()

    if 'pycurl' in sys.modules and opts.push:
        AURPush(opts, args).run()
    else:
        AURSync(opts, args).run()

# vim:sw=4:ts=4:sts=4:
