#!/usr/bin/env python
#
# slurpy - AUR search/download/update helper
#
# Randy Morris <randy@rsontech.net>
#
# depends:
#           python
#
# optdepends: 
#           python-cjson -  speeds up processing significantly on operations
#                           with many results
#           python-pycurl - enable uploading packages to the AUR
#
#
# Credits: This code started off as a port of the original arson ruby code
#          written by Colin Shea.  It has since changed very much, but the
#          roots are still obvious.
#
#          Colin's project can be found at <http://evaryont.github.com/arson>
#
#          Contributors: elij <http://monkeyvschicken.net>
#                        MrElendig
#
# CREATED:  2008-08-22 18:41
# MODIFIED: 2009-10-06 12:12

VERSION = '2.1.5'

import glob
import os
import re
import sys
import gzip
import urllib
import urllib2
import subprocess

from getpass import getpass
from distutils import version as Version
from optparse import OptionParser
from cStringIO import StringIO
from tarfile import TarFile

try:
    import cjson as Json
except ImportError:
    import json as Json

try:
    import pycurl
except ImportError:
    __doc__ = """Usage: slurpy [options] <operation> PACKAGE [PACKAGE2..]

 Operations:
  -d, --download          download PACKAGE(s)
                             if passed twice will also download dependencies
                             from the AUR
  -i, --info              show info for PACKAGE(s)
  -s, --search            search for PACKAGE(s)
  -u, --update            check explicitly installed packages for available
                          updates
                             if passed with --download flag(s), perform download
                             operation for each package with an available update

 General options:
  -c, --color             use colored output
  -f, --force             overwrite existing files when dowloading
  -q, --quiet             show only package names in search/update results
  -t DIR, --save-to=DIR   target directory where files will be downloaded
  -v, --verbose           show info messages
                             if passed twice will also show debug messages

  -h, --help              show this message
      --version           show version information"""
else:
    __doc__ = """Usage: slurpy [options] [--sync] <operation> PACKAGE [PACKAGE2..] 
       slurpy [options] --push FILE1 [FILE2..] 

 Modes:
  -S, --sync              Retrieve package(s)/info from the AUR (DEFAULT)
  -P, --push              Upload a package to the AUR

 Sync Operations:              
  -d, --download          download PACKAGE(s)
                             if passed twice will also download dependencies
                             from the AUR
  -i, --info              show info for PACKAGE(s)
  -s, --search            search for PACKAGE(s)
  -u, --update            check explicitly installed packages for available
                          updates 
                             if passed with --download flag(s), perform download
                             operation for each package with an available update

 Push Options:
  -C, --category          package category in the AUR
                             New Package DEFAULT: none
                             Update DEFAULT: current category in the AUR
  -U, --user              AUR username
      --cookie-file       file to store AUR session information in

 General options:
  -c, --color             use colored output
  -f, --force             overwrite existing files when dowloading
  -q, --quiet             show only package names in search/update results
  -t DIR, --save-to=DIR   target directory where files will be downloaded
  -v, --verbose           show info messages
                             if passed twice will also show debug messages

  -h, --help              show this message
      --version           show version information"""

# utility functions
def json_decode(url):
    """Open <url> and decode the json response"""
    request = urllib2.Request(url)
    request.add_header("Accept-encoding", "gzip")
    request.add_header("User-agent", "slurpy/%s" % VERSION)
    try:
        usock = urllib2.urlopen(request)
        data = usock.read()
        if usock.headers.get('content-encoding', None) == 'gzip':
            data = gzip.GzipFile(fileobj=StringIO(data)).read()
        usock.close()
    except:
        ## just rethrow for now
        raise
    finally:
        # clean up
        del request
        del usock
    try:
        return Json.decode(data)
    except AttributeError:
        return Json.loads(data)

def read_config():
    """Read in the slurpy runtime config to set default options."""
    home = os.getenv('HOME')
    xdg_config_home = os.getenv('XDG_CONFIG_HOME')
    if xdg_config_home is None:
        xdg_config_home = "%s/.config/" % home

    # configuration options, sane defaults
    AUR_USER = None
    COOKIE_FILE = "~/.slurpy.aurcookie"
    TARGET_DIR = "."
    USE_COLOR = False
    VERBOSE = 0
    
    conf = None
    if os.path.exists(xdg_config_home + "/slurpy/slurpyrc"):
        conf = open(xdg_config_home + "/slurpy/slurpyrc")
    elif os.path.exists(home + "/.slurpyrc"):
        conf = open(home + "/.slurpyrc")

    if conf is not None:
        try:
            exec(conf.read())
        except (SyntaxError, NameError):
            print "error: There is a syntax error in your config file."
            print "Please correct this and try again."
            sys.exit(1)

    return {
            'color': USE_COLOR,
            'cookie_file': COOKIE_FILE,
            'target_dir': os.path.expanduser(TARGET_DIR),
            'user': AUR_USER,
            'verbose': VERBOSE,
            }

def strip_slashes(str):
    """Remove extraneous backslashes (\) from <str>"""
    if str is None:
        return "None"
    str = str.encode('UTF-8')
    if 'cjson' in sys.modules:
        return str.replace('\/', '/')
    return str

# class definitions
class SlurpyFrontEnd():
    """
    Handles all output pertaining to packages returned by the Slurpy* classes

    """

    COLOR_CONF = "/etc/pacman.d/color.conf"

    def __init__(self, opts, args):
        """Sets up colors and sets opts for the class"""
        self.opts = opts
        self.args = args
        if opts.sync:
            self.sync = AURSync(opts, args)
        else:
            self.push = AURPush(opts, args)

        # default colors to be used if COLOR_CONF is not readable
        self.colors = {"red":"boldred", "green":"boldgreen",
                       "yellow":"boldyellow", "blue":"boldblue",
                       "magenta":"boldmagenta", "cyan":"boldcyan",
                       "white":"boldwhite"}

        # read COLOR_CONF to get pacman-color's settings
        if self.opts.color:
            try:
                fd = open(self.COLOR_CONF, 'r')
                conf = fd.read()
                fd.close()
                for color in self.colors:
                    col = re.findall("^\s*"+color.capitalize()+".*", conf, re.M) 
                    if len(col):
                        col = col[0].split('=')[1].strip()
                        col = re.sub("intensive\s*", "bold", col)
                        self.colors[color] = col
            except IOError:
                self.write_ln("Error reading color.conf, using default colors",
                              type="debug")
        

    def search(self):
        pkgs = []
        for arg in self.args:
            try:
                pkgs.extend(self.sync.search(arg))
            except JSONError, e:
                self.write_ln(e.value, type="error")
                continue

        if pkgs == []:
            return

        # sort
        spkgs = sorted(pkgs, key=lambda k: k[self.sync.NAME])
        del pkgs

        # remove dups -- note: extra list traversal, but imo it's worth it
        i = 0
        for pkg in spkgs:
            if pkg == spkgs[i]: 
                continue
            i += 1
            spkgs[i] = pkg
        del spkgs[i+1:]

        for pkg in spkgs:
            if self.opts.quiet:
                self.write_ln(pkg[self.NAME], color="white")
            else:
                self.write("aur", color="magenta")
                self.write("/")
                self.write(pkg[self.sync.NAME], color="white")
                if pkg[self.sync.OUT_OF_DATE] == '0':
                    self.write_ln(" " + pkg[self.sync.VERSION], color="green")
                else:
                    self.write_ln(" " + pkg[self.sync.VERSION], color="red")

                self.write_ln("   ", strip_slashes(pkg[self.sync.DESCRIPTION]))
        

    def info(self):
        for arg in self.args:
            try:
                pkg = self.sync.info(arg)
            except JSONError, e:
                self.write_ln(e.value, type="error")
                sys.exit(1)

            if pkg[self.sync.OUT_OF_DATE] == '0':
                out_of_date = "No"
            else:
                out_of_date = "Yes"

            self.write("Repository      : ")
            self.write_ln("aur", color="magenta")
            self.write("Name            : ")
            self.write_ln(pkg[self.sync.NAME], color="white")
            self.write("Version         : ")
            if out_of_date == "Yes":
                self.write_ln(pkg[self.sync.VERSION], color="red")
            else:
                self.write_ln(pkg[self.sync.VERSION], color="green")
            self.write("URL             : ")
            self.write_ln(strip_slashes(pkg[self.sync.URL]), color="cyan")
            self.write("AUR Page        : ")
            self.write_ln(self.sync.AUR_URL + '/packages.php?ID=' + pkg[self.sync.ID], color="cyan")
            self.write("Category        : ")
            self.write_ln(self.sync.CATEGORIES[int(pkg[self.sync.CATEGORY])])
            self.write("Licenses        : ")
            self.write_ln(strip_slashes(pkg[self.sync.LICENSE]))
            self.write("Number of Votes : ")
            self.write_ln(pkg[self.sync.VOTES])
            self.write("Out of Date     : ")
            if out_of_date == "Yes":
                self.write_ln(out_of_date, color="red")
            else:
                self.write_ln(out_of_date, color="green")
            self.write("Description     : ")
            self.write_ln(strip_slashes(pkg[self.sync.DESCRIPTION]), "\n")

    def download(self):
        try:
            if self.opts.target_dir is not None:
                os.chdir(self.opts.target_dir)
        except OSError:
            self.write_ln(self.opts.target_dir, "does not exist or is not",
                          "a directory", type="error")
            sys.exit(1)

        dledpkgs = [] # holds list of downloaded pkgs
        repodeps = [] # holds list of dependencies available in pacman repos
        for arg in self.args:
            if arg in repodeps: 
                continue

            try:
                pkg, deps = self.sync.download(arg)
            except JSONError, e:
                self.write_ln(e.value, type="error")
                continue
            except FileExistsError, e:
                self.write_ln(e.fname, type="error")
                continue
            except DirectoryExistsError, e:
                self.write_ln(e.dir, type="error")
                continue

            if pkg is not None:
                dledpkgs.append(pkg)
            if deps is not None:
                repodeps.extend(deps)

            if self.opts.download > 1:
                deps = self.sync.get_depends(arg)

                for dep in deps:
                    dpkgs = []
                    drdeps = []

                    # download dependencies, but ignore already downloaded pkgs
                    try:
                        dpkg, ddeps = self.sync.download(dep, dledpkgs)
                    except JSONError, e:
                        self.write_ln(e.value, type="error")
                        continue
                    except FileExistsError, e:
                        self.write_ln(e.fname, type="error")
                        continue
                    except DirectoryExistsError, e:
                        self.write_ln(e.dir, type="error")
                        continue

                    if dpkg is not None:
                        dpkgs.append(dpkg)
                    if ddeps is not None:
                        drdeps.extend(ddeps)

                    for p in dpkgs:
                        d = self.sync.get_depends(p)
                        if d != []:
                            deps.extend(d)
                    
                    if dpkgs != []:
                        dledpkgs.extend(dpkgs)
                    if drdeps != []:
                        repodeps.extend(drdeps)

        # remove dups
        repodeps = list(set(repodeps))
        repodeps.sort()
        dledpkgs.sort()

        self.display_result(dledpkgs, repodeps)

    def display_result(self, pkgs, deps):
        """Print a nicely formated result of <pkgs> and <deps>"""
        if pkgs:
            if len(pkgs) == 1 and not deps:
                self.write(pkgs[0], color="white")
                self.write(" downloaded to ")
                self.write_ln(os.getcwd(), color="green")
            else:
                self.write("Packages downloaded to ")
                self.write(os.getcwd(), color="green")
                self.write_ln(":")
                for pkg in pkgs:
                    self.write_ln("   ", pkg, color="white")
        if deps:
            if len(deps) == 1 and not pkgs:
                self.write(deps[0], color="white")
                self.write(" is available in ")
                self.write_ln("pacman repos", color="yellow")
            else:
                self.write("\nDependencies found in ")
                self.write("pacman repos", color="yellow")
                self.write_ln(":")
                for dep in deps:
                    self.write_ln("   ", dep, color="white")

    def colorfy(self, string, col):
        """Returns <string> with the ansi escape codes wrapping the string"""
        colors = {"black":      "0",  "gray":           "9",
                  "red":        "1",  "boldred":        "10",
                  "green":      "2",  "boldgreen":      "11",
                  "yellow":     "3",  "boldyellow":     "12",
                  "blue":       "4",  "boldblue":       "13",
                  "magenta":    "5",  "boldmagenta":    "14",
                  "cyan":       "6",  "boldcyan":       "15",
                  "white":      "7",  "boldwhite":      "16",
                  "foreground": "8",  "boldforeground": "17"}

        if not self.opts.color or col not in colors:
            return string
        elif self.colors[col][:4] == "bold":
            col = self.colors[col][4:]
            return "\033[1;3" + colors[col] + "m" + string + "\033[1;m"
        else:
            return "\033[3" + colors[self.colors[col]] + "m" + string + \
                    "\033[1;m"

    def update(self):
        pkgs = self.sync.update()
        for pkg in pkgs:
            if not self.opts.download:
                pkgname = self.colorfy(pkg[self.sync.NAME], 'white')
                inst_ver = self.colorfy(pkg['_inst_ver'], 'green')
                
                if self.opts.quiet:
                    self.write_ln(pkgname)
                elif self.opts.verbose >= 1:
                    if pkg[self.sync.OUT_OF_DATE] == '0':
                        aur_ver = self.colorfy(pkg[self.sync.VERSION], 'green')
                    else:
                        aur_ver = self.colorfy(pkg[self.sync.VERSION], 'red')
                    self.write_ln('{0} {1} -> {2}'.format(pkgname, inst_ver,
                                                          aur_ver))
                else:
                    self.write_ln('{0} {1}'.format(pkgname, inst_ver))
        return pkgs

    def write(self, *args, **kwargs):
        """print wrapper: provides an easy way to print colors and templates

        optional kwargs: color = one of the following colors:
                                 red, green, yellow, blue, magenta, cyan, white

                         type = templates defined as follows:
                            "info",    prepends white "info: " to str
                            "debug",   prepends blue "debug: " to str
                            "warning", prepends yellow "warning: " to str
                            "error",   prepends red "error: " to str
        """

        string = ' '.join(args)

        for arg in ['color', 'type']:
            if arg not in kwargs:
                kwargs[arg] = False

        if kwargs['color']:
            string = self.colorfy(string, kwargs['color'])

        if kwargs['type'] == "error":
            string = self.colorfy("error: ", "red") + string
        elif kwargs['type'] == "warning":
            string = self.colorfy("warning: ", "yellow") + string
        elif kwargs['type'] == "info":
            string = self.colorfy("info: ", "magenta") + string
            if self.opts.verbose > 0:
                sys.stdout.write(string)
            return
        elif kwargs['type'] == "debug":
            string = self.colorfy("debug: ", "cyan") + string
            if self.opts.verbose > 1:
                sys.stdout.write(string)
            return

        sys.stdout.write(string)

    def write_ln(self, *args, **kwargs):
        """print wrapper: calls self.write() and appends a newline if anything
        was actually written (due to verbosity level)"""
        args = list(args) + ['\n']
        self.write(*args, **kwargs)

    def login():
        if self.opts.user is None:
            self.opts.user = raw_input('User: ')

        password = getpass('Password: ')
        if not slurpy.push.login(self.opts.user, passwd):
            self.write_ln("Bad username or password. Please try again.", 
                          type="error")
            sys.exit(1)

    def upload():
        for arg in self.args:
            if not os.path.isfile(arg):
                self.write_ln(arg, "does not exist or is not a file.",
                           type="error")
                sys.exit(1)

            try:
                success = self.push.upload(arg)
            except FileUploadError, e:
                self.write_ln(e.value, type="error")

            if success:
                self.write(pkg, color="white")
                self.write_ln(" has been uploaded.")
            else:
                self.write("Unknown error.", type="error")
            

class Slurpy():
    
    """Main Slurpy class"""

    AUR_URL = "http://aur.archlinux.org"

class AURSync(Slurpy):

    """ Handles all pull requests from the AUR """

    PACMAN_CACHE = "/var/lib/pacman/local"
    PACMAN_CONF = "/etc/pacman.conf"
    PACMAN_REPOS = ['core', 'extra', 'community']
    PACMAN_SYNC = "/var/lib/pacman/sync/"

    INFO_URL = "http://aur.archlinux.org/rpc.php?type=info&arg="
    SEARCH_URL = "http://aur.archlinux.org/rpc.php?type=search&arg="

    # json constants
    ID = "ID"
    NAME = "Name"
    VERSION = "Version"
    CATEGORY = "CategoryID"
    DESCRIPTION = "Description"
    LOCATION = "LocationID"
    URL = "URL"
    PATH = "URLPath"
    LICENSE = "License"
    VOTES = "NumVotes"
    OUT_OF_DATE = "OutOfDate"
    CATEGORIES = [None, None, "daemons", "devel", "editors", "emulators",
                  "games", "gnome", "i18n", "kde", "lib", "modules",
                  "multimedia", "network", "office", "science", "system",
                  "x11", "xfce", "kernels"]


    def __init__(self, opts, args):
        self.opts = opts
        self.args = []
        
        # encode white space
        for arg in args:
            self.args.append(arg.replace(" ", "%20"))

        # enable testing repo if enabled on the machine
        try:
            fd = open(self.PACMAN_CONF, 'r')
            conf = fd.read()
            fd.close()
        except IOError:
            #self.write_ln("Error reading pacman.conf, testing repo will"
            #               "remain disabled", type="info")
            pass

        if re.search('^\s*\[testing\]', conf, re.M):
            self.PACMAN_REPOS = ['testing'] + self.PACMAN_REPOS
            #self.write_ln("Testing repo enabled", type="debug")

    def download(self, pkgname, ignore=[]):
        """Downloads all packages in <self.args>
        
        Returns any (make)dependencies of that package found in the PKGBUILD.
        """

        if pkgname in ignore:
            return(none, [])

        if self.in_sync_db(pkgname) != False:
            return(None, [pkgname])

        json = json_decode(self.INFO_URL + pkgname)

        if json['type'] == 'error':
            raise JSONError("%s %s" % (pkgname, json['results']))

        pkg = json['results']
        url = self.AUR_URL + strip_slashes(pkg[self.PATH])
        c_url = self.AUR_URL + '/packages/' + pkgname + '/' + pkgname + '.tar.gz'
        if url != c_url:
            #self.write_ln("There might be a problem with this package in "
            #              "the AUR's database.", type="info")
            #self.write_ln("Using constructed url instead.", type="info")
            url = c_url 
            

        fname = url.split('/')[-1].split('.tar.gz')[0]
        if not self.opts.force:
            if os.path.exists(fname + '.tar.gz'):
                raise FileExistsError("%s/%s.tar.gz exists." %(os.getcwd(), fname))

            if os.path.exists(fname):
                raise DirectoryExistsError("%s/%s exists." %(os.getcwd(), fname))

        # download .tar.gz
        fd = open(fname + '.tar.gz', 'w')
        fd.write(urllib.urlopen(url).read())
        fd.close()

        # unzip -- per aur guidelines, all fnames must be .tar.gz'd
        try:
            fd = TarFile.open(fname + '.tar.gz', 'r:gz')
            fd.extractall()
            fd.close()
        except: 
            #self.write_ln("Error extracting archive %s.tar.gz" % fname,  
            #               type="error")
            os.unlink(fname + '.tar.gz')
            sys.exit(1)

        os.unlink(fname + '.tar.gz')
        return(fname, None)
            

    def get_depends(self, pkgname):
        """stub"""
        # download deps
        if self.opts.download > 1:
            fd = open('%s/%s/PKGBUILD' % (self.opts.target_dir, pkgname), 'r')
            pkgb = fd.read()
            fd.close()

            deps = []
            deptup = re.findall('[^(opt)](make)?depends=\((.*?)\)', 
                                pkgb, re.S)
            for group in deptup:
                for dep in group[1].split():
                    dep = re.findall('(.[^<>=]*).*', dep)[0].strip("'")
                    deps.append(dep)

            return deps

    def in_sync_db(self, name): 
        """Checks if <name> exists in the local syncdb for <repo>

        Returns true if found, otherwise false
        """
        for repo in self.PACMAN_REPOS:
            syncd = self.PACMAN_SYNC + repo
            if glob.glob(syncd + "/" + name + "-*"):
                return repo
        return False

    def info(self, pkgname):
        """Prints all known info about each package in <self.args>"""
        json = json_decode(self.INFO_URL + pkgname)
        if json['type'] == 'error':
            raise JSONError(json['results'])
            #self.write_ln(json['results'], type="error")
            sys.exit(1)
        return json['results']

    def run(self):
        """Main processing for AURSync.

        Handles all function dispatching and pre/post result output.
        """
        pass

    def search(self, pkgname):
        """Search the AUR for <self.args> and print results to the screen"""
        pkgs = []
        filter = None
        # user passed a filter argument
        if pkgname[0] == '^' or pkgname[-1] == '$':
            filter = re.compile(pkgname)
            pkgname = pkgname.strip("^$")

        json = json_decode(self.SEARCH_URL + pkgname)
        if json['type'] == 'error':
            if json['results'].lower() != "no results found":
                raise JSONError(json['results'])
        else:
            if filter is None:
                pkgs.extend(json['results'])
            else:
                for pkg in json['results']:
                        if filter.search(pkg[self.NAME]):
                            pkgs.append(pkg)

        return pkgs

    def update(self):
        """Checks all explicitly installed packages for updates in the AUR.
        Returns a list dicts representing the package.'"""
        updates = []

        if not self.opts.quiet:
            #self.write_ln("Checking for package updates... ", type="info")
            pass

        with subprocess.Popen(["pacman", "-Qm"], stdout=subprocess.PIPE).stdout as fd:
            data = fd.readlines()
        
        for ln in data:
            name, inst_ver  = ln[:-1].split(' ')
            pkg = json_decode(self.INFO_URL + name)['results']
            if pkg != "No result found":
               aur_ver = Version.LooseVersion(pkg[self.VERSION])
               inst_ver = Version.LooseVersion(inst_ver)
               if aur_ver > inst_ver:
                   pkg['_inst_ver'] = str(inst_ver)
                   updates.append(pkg)

        return updates

class AURPush(Slurpy):
    
    """ Handles all push requests to the AUR """

    AUR_SUBMIT_URL = "http://aur.archlinux.org/pkgsubmit.php"

    def __init__(self, opts, args):

        self.opts = opts
        self.args = args
        self.buffer = StringIO()

        self.curl = pycurl.Curl()
        self.curl.setopt(pycurl.HTTPHEADER, ["Expect:"])
        self.curl.setopt(pycurl.COOKIEJAR, self.opts.cookie_file)
        self.curl.setopt(pycurl.WRITEFUNCTION, self.buffer.write)
        self.curl.setopt(pycurl.FOLLOWLOCATION, 1)

    def __del__(self):
        """ Clean up curl and cookie file """
        self.curl.close()
        if os.path.exists(self.opts.cookie_file):
            os.unlink(self.opts.cookie_file)

    def login(self, user, passwd):
        """ Log in to the AUR web interface with self.opts.user,
        prompt for password.
        """
        data = [
            ('user', user),
            ('passwd', passwd)]

        self.curl.setopt(pycurl.HTTPPOST, data)
        self.curl.setopt(pycurl.URL, self.AUR_URL)
        self.curl.perform()
        
        # Bad username or password
        if self.buffer.getvalue().find("Bad username or password") != -1:
            return False
        return True

    def run(self):
        """ Main processing for AURPush """
        pass

    def upload(self, fname):
        """ Upload files in self.args to the aur """

        data = [
            ('pkgsubmit', '1'),
            ('category', '%s' % AURSync.CATEGORIES.index(self.opts.category)),
            ('pfile', (pycurl.FORM_FILE, fname))]

        self.curl.setopt(pycurl.HTTPPOST, data)
        self.curl.setopt(pycurl.URL, self.AUR_SUBMIT_URL)

        self.buffer.truncate(0)
        try:
            self.curl.perform()
        except:
            raise FileUploadError(fname, "Something is wrong with the "
                                  "selected file.\nIf it is a .tar.gz, "
                                  "try rebuilding it.")

        if self.buffer.getvalue().find("not allowed to overwrite") != -1:
            raise FileUploadError(fname, "You do not own this package and "
                                  "can not overwrite these files.")
        elif self.buffer.getvalue().find("Unknown file format") != -1:
            raise FileUploadError(fname, "Incorrect file format. Upload "
                                  "must conform to AUR packaging "
                                  "guidelines.")

        idx = self.buffer.getvalue().find("<span class='f2'>")
        if idx != -1:
            pkg = self.buffer.getvalue()[17+idx:]

            idx = pkg.find("</span>")
            if idx != -1:
                pkg = pkg[:idx]
                
                if pkg is not None:
                    return True
        return False

# exceptions

class JSONError(Exception):
    """To be thrown when the AUR returns errors in the JSON results"""

    def __init__(self, value):
        self.value = value.lower()

class FileExistsError(Exception):
    """To be thrown when a file exists that we need to write to"""

    def __init__(self, fname):
        self.fname = fname

class FileUploadError(Exception):
    """To be thrown when pycurl can not upload the file"""

    def __init__(self, fname, msg):
        self.fname = fname
        self.msg = msg

class DirectoryExistsError(Exception):
    """To be thrown when a directory exists that we need to write to"""

    def __init__(self, dir):
        self.dir = dir

# main processing 
if __name__ == '__main__':

    conf = read_config()

    _version = ' '.join(("%prog",VERSION))
    parser = OptionParser(version=_version, conflict_handler="resolve")
    parser.add_option('-d', '--download', action='count')
    parser.add_option('-c', '--color', action='store_true',
                            default=conf['color'])
    parser.add_option('-f', '--force', action='store_true')
    parser.add_option('-h', '--help', action='store_true')
    parser.add_option('-i', '--info', action='store_true')
    parser.add_option('-q', '--quiet', action='store_true')
    parser.add_option('-s', '--search', action='store_true')
    parser.add_option('-t', '--save-to', dest='target_dir', action='store',
                            default=conf['target_dir'])
    parser.add_option('-u', '--update', action='store_true')
    parser.add_option('-v', '--verbose', action='count',
                            default=conf['verbose'])
    parser.add_option('-S', '--sync', action='store_true', default=True)

    if 'pycurl' in sys.modules:
        parser.add_option('-C', '--category', action='store', default=None)
        parser.add_option('-P', '--push', action='store_true', default=False)
        parser.add_option('-U', '--user', action='store', default=conf['user'])
        parser.add_option('', '--cookie-file', action='store',
                              default=conf['cookie_file'])

    opts, args = parser.parse_args()

    slurpy = SlurpyFrontEnd(opts,args)

    if 'pycurl' in sys.modules and opts.push:
        if opts.category is not None:
            if opts.category not in AURSync.CATEGORIES:
                slurpy.write_ln("Category does not exist, please enter one of "
                              "the following categories:", type="error")
                for cat in AURSync.CATEGORIES[2:]:
                    slurpy.write_ln(cat)

                sys.exit(1)

        slurpy.login()
        slurpy.upload()
    else:
        if opts.update and opts.download:
            updates = [] # holds all available updates

            try:
                if opts.target_dir is not None:
                    os.chdir(opts.target_dir)
            except OSError:
                slurpy.write_ln(opts.target_dir, "does not exist or is not",
                              "a directory", type="error")
                sys.exit(1)

            slurpy.write("Downloading updates to ")
            slurpy.write_ln(os.getcwd(), color="green")

            for pkg in slurpy.update():
                updates.append(pkg[AURSync.NAME]) 

            if updates == []:
                slurpy.write_ln("No updates available")
            else:
                slurpy.args = updates
                slurpy.download()
        elif opts.info:
            slurpy.info()
        elif opts.search:
            slurpy.search()
        elif opts.update:
            slurpy.update()
        elif opts.download:
            slurpy.download()
        else:
            slurpy.write_ln(__doc__)


# vim:sw=4:ts=4:sts=4:
