#!/usr/bin/env python
#
# slurpy - AUR search/download/update helper
#
# Randy Morris <randy@rsontech.net>
#
# depends:
#           python
#
# optdepends: 
#           python-cjson - speeds up processing significantly on operations
#                          with many results
#
#
# Credits: This code started off as a port of the original arson ruby code
#          written by Colin Shea.  It has since changed very much, but the
#          roots are still obvious.
#
#          Colin's project can be found at <http://evaryont.github.com/arson>
#
# CREATED:  2008-08-22 18:41
# MODIFIED: 2009-06-24 16:03

"""usage: slurpy [options] <operation> PACKAGE [PACKAGE2..] 
 operations:              
  -d, --download          download PACKAGE(s)
                             if passed twice will also download dependencies
                             from the AUR
  -i, --info              show info for PACKAGE(s)
  -s, --search            search for PACKAGE(s)
  -u, --update            check explicitly installed packages for available
                          updates 
                             if passed with --download flag(s), perform download
                             operation for each package with an available update
 options:
  -c, --color             use colored output
  -q, --quiet             show only package names in search/update results
  -t DIR, --save-to=DIR   target directory where files will be downloaded
  -v, --verbose           show warning and info messages

  -h, --help              show this message
      --version           show version information"""

import glob
import os
import re
import string
import sys
import urllib

from distutils import version as Version
from optparse import OptionParser
from tarfile import TarFile

try:
    import cjson as Json
except ImportError:
    import json as Json

# utility functions
def json_decode(url):
    """Open <url> and decode the json response"""
    try: 
        return Json.decode(urllib.urlopen(url).read())
    except AttributeError:
        return Json.loads(urllib.urlopen(url).read())

def strip_slashes(str):
    """Remove extraneous backslashes (\) from <str>"""
    return re.sub(r"\\(.)", r"\1", str.encode('UTF-8'))


# class definitions
class Slurpy():
    
    """Slurpy base class
        
    Defines color and output functions to be used in aur and abs subclasses.
    """

    COLOR_CONF = "/etc/pacman.d/color.conf"

    def __init__(self, opts, args):
        """Sets up colors and sets opts and args for the class"""
        self.opts = opts
        self.args = args

        # default colors to be used if COLOR_CONF is not readable
        self.colors = {"red":"boldred", "green":"boldgreen",
                       "yellow":"boldyellow", "blue":"boldblue",
                       "magenta":"boldmagenta", "cyan":"boldcyan",
                       "white":"boldwhite"}

        # read COLOR_CONF to get pacman-color's settings
        try:
            fp = open(self.COLOR_CONF, 'r')
            conf = fp.read()
            fp.close()
        except IOError:
            if self.opts.verbose:
                self.write_ln("error reading color.conf, using default colors",
                              type="warning")
            return

        for color in self.colors:
            set = re.findall("^\s*"+color.capitalize()+".*", conf, re.M) 
            if len(set):
                set = set[0].split('=')[1].strip()
                set = re.sub("intensive\s*", "bold", set)
                self.colors[color] = set

    def download(self):
        """Must be overridden.
        
        All subclasses must have at lease a download function or they are 
        pointless.
        """
        pass

    def run(self):
        """Must be overridden.
        
        All subclasses must have a run method where function dispatching is
        handled.
        """
        pass

    def write(self, *args, **kwargs):
        """print wrapper: provides an easy way to print colors and templates

        optional kwargs: color = one of the following colors:
                                 red, green, yellow, blue, magenta, cyan, white

                         type = templates defined as follows:
                            "info",    prepends white "info: " to str
                            "debug",   prepends blue "debug: " to str
                            "warning", prepends yellow "warning: " to str
                            "error",   prepends red "error: " to str
        """

        str = ' '.join(args)

        for arg in ['color', 'type']:
            if arg not in kwargs:
                kwargs[arg] = False

        if kwargs['color']:
            str = self.colorfy(str, kwargs['color'])

        # templates
        if kwargs['type'] == "error":
            str = self.colorfy("error: ", "red") + str
        elif kwargs['type'] == "warning":
            str = self.colorfy("warning: ", "yellow") + str
        elif kwargs['type'] == "debug":
            str = self.colorfy("debug: ", "cyan") + str
        elif kwargs['type'] == "info":
            str = self.colorfy("info: ", "white") + str

        sys.stdout.write(str)

    def write_ln(self, *args, **kwargs):
        self.write(*args, **kwargs)
        self.write("\n")

    def colorfy(self, str, col):
        """Returns <str> with the ansi escape codes wrapping the string"""
        colors = {"black":      "0",  "gray":           "9",
                  "red":        "1",  "boldred":        "10",
                  "green":      "2",  "boldgreen":      "11",
                  "yellow":     "3",  "boldyellow":     "12",
                  "blue":       "4",  "boldblue":       "13",
                  "magenta":    "5",  "boldmagenta":    "14",
                  "cyan":       "6",  "boldcyan":       "15",
                  "white":      "7",  "boldwhite":      "16",
                  "foreground": "8",  "boldforeground": "17"}

        if not self.opts.color or col not in colors:
            return str
        elif self.colors[col][:4] == "bold":
            col = self.colors[col][4:]
            return "\033[1;3" + colors[col] + "m" + str + "\033[1;m"
        else:
            return "\033[3" + colors[self.colors[col]] + "m" + str + "\033[1;m"

class SlurpyAUR(Slurpy):

    """Does all AUR work"""

    DOWNLOAD_URL = "http://aur.archlinux.org"
    INFO_URL = "http://aur.archlinux.org/rpc.php?type=info&arg="
    SEARCH_URL = "http://aur.archlinux.org/rpc.php?type=search&arg="
    PACMAN_CACHE = "/var/lib/pacman/local"
    PACMAN_SYNC = "/var/lib/pacman/sync/"

    # json constants
    ID = "ID"
    NAME = "Name"
    VERSION = "Version"
    CATEGORY = "CategoryID"
    DESCRIPTION = "Description"
    LOCATION = "LocationID"
    URL = "URL"
    PATH = "URLPath"
    LICENSE = "License"
    VOTES = "NumVotes"
    OUT_OF_DATE = "OutOfDate"
    CATEGORIES = [None, None, "daemons", "devel", "editors", "emulators", 
                               "games", "gnome", "i18n", "kde", "lib", 
                               "modules", "multimedia", "network", "office", 
                               "science", "system", "x11", "xfce", "kernels"]

    def display_result(self, pkgs, deps):
        """Print a nicely formated result of <pkgs> and <deps>"""
        if pkgs:
            if len(pkgs) == 1 and not deps:
                self.write(pkgs[0], color="white")
                self.write(" downloaded to ")
                self.write_ln(os.getcwd(), color="green")
            else:
                self.write("packages downloaded to ")
                self.write(os.getcwd(), color="green")
                self.write_ln(":")
                for pkg in pkgs:
                    self.write_ln("   ", pkg, color="white")
        if deps:
            if len(deps) == 1 and not pkgs:
                self.write(deps[0], color="white")
                self.write(" is available in ")
                self.write_ln("pacman repos", color="yellow")
            else:
                self.write("\ndependencies found in ")
                self.write("pacman repos", color="yellow")
                self.write_ln(":")
                for dep in deps:
                    self.write_ln("   ", dep, color="white")

    def download(self, ignore=[]):
        """Downloads all packages in <self.args>
        
        Returns any (make)dependencies of that package found in the PKGBUILD.
        """
        dledpkgs = [] # holds list of downloaded pkgs
        repodeps = [] # holds list of dependencies available in pacman repos
        for arg in self.args:
            if arg in ignore: 
                continue

            if (self.in_sync_db("core", arg) or self.in_sync_db("extra", arg) 
                    or self.in_sync_db("community", arg)):
                repodeps.append(arg)
                continue

            json = json_decode(self.INFO_URL + arg)

            if json['type'] == 'error':
                self.write_ln(arg, json['results'].lower(), type="error")
                return(dledpkgs, repodeps)

            pkg = json['results']
            url = self.DOWNLOAD_URL + strip_slashes(pkg[self.PATH])
            file = url.split('/')[-1].split('.tar.gz')[0]
            if not self.opts.force:
                if os.path.exists(file + '.tar.gz') or os.path.exists(file):
                    self.write_ln("file exists. pass -f to force this",
                               "operation", type="error")
                    sys.exit()

            # download .tar.gz
            fp = open(file + '.tar.gz', 'w')
            fp.write(urllib.urlopen(url).read())
            fp.close()

            # unzip -- per aur guidelines, all files must be .tar.gz'd
            try:
                fp = TarFile.open(file + '.tar.gz', 'r:gz')
                fp.extractall()
                fp.close()
            except:
                self.write_ln("error extracting archive %s.tar.gz" % file, 
                           type="error")
                os.unlink(file + '.tar.gz')
                sys.exit()

            os.unlink(file + '.tar.gz')
            dledpkgs.append(file)
            
            # download deps
            if self.opts.download > 1:
                fp = open(file + '/PKGBUILD', 'r')
                pkgb = fp.read()
                fp.close()

                deps = []
                deptup = re.findall('[^(opt)](make)?depends=\((.*?)\)', 
                                    pkgb, re.S)
                for group in deptup:
                    for dep in group[1].split():
                        dep = re.findall('(.[^<>=]*).*', dep)[0].strip("'")
                        deps.append(dep)

                # download dependencies, but ignore already downloaded pkgs
                pkgs, deps = SlurpyAUR(self.opts,deps).download(dledpkgs)

                if pkgs != []:
                    dledpkgs.extend(pkgs)
                if deps != []:
                    repodeps.extend(deps)

        # remove dups
        repodeps = list(set(repodeps))

        return dledpkgs, repodeps

    def info(self):
        """Prints all known info about each package in <self.args>"""
        for arg in self.args:
            json = json_decode(self.INFO_URL + arg)
            if json['type'] == 'error':
                self.write_ln(json['results'].lower(), type="error")
                sys.exit()
            pkg = json['results']
            if pkg[self.LOCATION] == 3:
                repo = "community"
            else:
                repo = "aur"

            if pkg[self.OUT_OF_DATE] == '0':
                out_of_date = "No"
            else:
                out_of_date = "Yes"

            self.write("Repository      : ")
            self.write_ln(repo, color="magenta")
            self.write("Name            : ")
            self.write_ln(pkg[self.NAME], color="white")
            self.write("Version         : ")
            if out_of_date == "Yes":
                self.write_ln(pkg[self.VERSION], color="red")
            else:
                self.write_ln(pkg[self.VERSION], color="green")
            self.write("URL             : ")
            self.write_ln(strip_slashes(pkg[self.URL]), color="cyan")
            self.write("Category        : ")
            self.write_ln(self.CATEGORIES[int(pkg[self.CATEGORY])])
            self.write("Licenses        : ")
            self.write_ln(strip_slashes(pkg[self.LICENSE]))
            self.write("Number of Votes : ")
            self.write_ln(pkg[self.VOTES])
            self.write("Out of Date     : ")
            if out_of_date == "Yes":
                self.write_ln(out_of_date, color="red")
            else:
                self.write_ln(out_of_date, color="green")
            self.write("Description     : ")
            self.write_ln(strip_slashes(pkg[self.DESCRIPTION]), "\n")

    def in_sync_db(self, repo, name): 
        """Checks if <name> exists in the local syncdb for <repo>

        Returns true if found, otherwise false
        """
        syncd = self.PACMAN_SYNC + repo
        if glob.glob(syncd + "/" + name + "-*"):
            return True
        return False

    def run(self):
        """Main processing for SlurpyAUR.

        Handles all function dispatching and pre/post result output.
        """
        if self.opts.update and self.opts.download:
            updates = []
            for pkg, version in self.update():
                updates.append(pkg) 
            self.args = updates

            self.write_ln("downloading updates...")
            self.display_result(*self.download())

        elif self.opts.download:
            try:
                if self.opts.target_dir is not None:
                    os.chdir(self.opts.target_dir)
            except OSError:
                self.write_ln("target dir does not exist or is not a",
                            "directory", type="error")
                sys.exit()

            self.display_result(*self.download())

        elif self.opts.info:
            self.info()
        elif self.opts.search:
            self.search()
        elif self.opts.update:
            for pkg, version in self.update():
                if self.opts.quiet:
                    self.write_ln(pkg)
                elif not self.opts.download:
                    self.write(pkg, color="white")
                    self.write_ln(" " + version, color="green")
        else:
            self.write_ln(__doc__)

    def search(self):
        """Search the AUR for <self.args> and print results to the screen"""
        pkgs = []
        for arg in self.args:
            json = json_decode(self.SEARCH_URL + arg)
            if json['type'] == 'error':
                if json['results'].lower() != "no results found":
                    self.write_ln(json['results'].lower(), type="error")
            else:
                pkgs.extend(json['results'])

        if pkgs == []:
            return

        # sort
        spkgs = sorted(pkgs, key=lambda k: k[self.NAME])

        # remove dups -- note: extra list traversal, but imo it's worth it
        i=0
        for pkg in spkgs:
            if pkg == spkgs[i]: continue
            i += 1
            spkgs[i] = pkg
        del spkgs[i+1:]

        for pkg in spkgs:
            if self.opts.quiet:
                self.write_ln(pkg[self.NAME], color="white")
            else:
                if pkg[self.LOCATION] == '3':
                    repo = "community"
                    category = ""
                else:
                    repo = "aur"

                self.write(repo, color="magenta")
                self.write("/")
                self.write(pkg[self.NAME], color="white")
                if pkg[self.OUT_OF_DATE] == '0':
                    self.write_ln(" " + pkg[self.VERSION], color="green")
                else:
                    self.write_ln(" " + pkg[self.VERSION], color="red")

                self.write_ln("   ", strip_slashes(pkg[self.DESCRIPTION]))

    def update(self):
        """Checks all explicitly installed packages for updates in the AUR"""
        updates = []

        if not self.opts.quiet:
            self.write_ln("checking for package updates... ")

        fp = os.popen("pacman -Qm")
        for ln in fp.readlines():
            name, version = ln[:-1].split(' ')
            pkg = json_decode(self.INFO_URL + name)['results']
            if pkg != "No result found":
                if self.update_available(pkg['Name'], pkg['Version']):
                    updates.append((name, pkg['Version']))

        return updates

    def update_available(self, name, version):
        """Helper for update(): does version comparison logic 
        
        Returns true if a new version is available, otherwise false
        """
        # We have to do some funky shit in here because of scm version 
        # numbering.

        # if the specific package/version is in the cache, there must not be an
        # update
        if os.path.exists(self.PACMAN_CACHE + "/" + name + "-" + version):
            return False
        else:
            glb = glob.glob(self.PACMAN_CACHE + "/" + name + "-*")

            # FIXME: wtf's the deal here?  Why a constant 1?  Could this
            # possibly return more than one?
            if len(glb) == 1: 
                pkg_name = os.path.basename(glb[0])
                
                # r_scm is a regex to match source control management package
                # version numbers
                r_scm = re.compile('-[0-9]{8}-[0-9]+$')

                # r_pkg is a regex to match any normal package version number
                r_pkg = re.compile(name + '-.+-[0-9]+$')

                if r_scm.search(pkg_name):
                    scm_installed = True
                elif r_pkg.search(pkg_name):
                    scm_installed = False
                else:
                    self.write_ln("failed to detect pkg version type. ",
                                  "please contact my developer with the ",
                                  "below info", type="error")
                    self.write_ln("pkg_name:", name, pkg_name)
                    self.write_ln("pkg_version:", version)
                    sys.exit()
                
                if r_scm.search(name + "-" + version):
                    scm_passed = True
                elif r_pkg.search(name+ "-" + version):
                    scm_passed = False

                if scm_passed and scm_installed:
                    passed_ver =\
                        r_scm.search(name + "-" + version).group().split("-")
                    inst_ver = r_scm.search(pkg_name).group().split("-")

                    # scm version numbers are always YYYYMMDD-REL
                    if passed_ver[1] > inst_ver[1]\
                         or (passed_ver[1] == inst_ver[1]\
                         and passed_ver[2] > inst_ver[2]):
                        return True
                    else:
                        return False
                else:
                    # compare LooseVersions of normal version numbers
                    inst_ver = r_pkg.search(pkg_name).group()[len(name)+1:]
                    inst_ver = Version.LooseVersion(inst_ver)
                    passed_ver = Version.LooseVersion(version)
                    if passed_ver > inst_ver:
                        return True
                    else:
                        return False

# main processing 
if __name__ == '__main__':

    parser = OptionParser(version="%prog 0.2.1", conflict_handler="resolve")
    parser.add_option('-a', '--abs', action='store_true')
    parser.add_option('-d', '--download', action='count')
    parser.add_option('-c', '--color', action='store_true')
    parser.add_option('-f', '--force', action='store_true')
    parser.add_option('-h', '--help', action='store_true')
    parser.add_option('-i', '--info', action='store_true')
    parser.add_option('-q', '--quiet', action='store_true')
    parser.add_option('-s', '--search', action='store_true')
    parser.add_option('-t', '--save-to', dest='target_dir', action='store') 
    parser.add_option('-u', '--update', action='store_true')
    parser.add_option('-v', '--verbose', action='store_true')
    
    opts, args =  parser.parse_args()

    if opts.abs:
        # future
        pass
    else:
        SlurpyAUR(opts, args).run()

# vim:sw=4:ts=4:sts=4:
