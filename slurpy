#!/usr/bin/env python
#
# slurpy - AUR search/download/update helper
#
# Randy Morris <randy@rsontech.net>
#
# depends:
#           python
#
# optdepends: 
#           python-cjson -  speeds up processing significantly on operations
#                           with many results
#           python-pycurl - enable uploading packages to the AUR
#
#
# Credits: This code started off as a port of the original arson ruby code
#          written by Colin Shea.  It has since changed very much, but the
#          roots are still obvious.
#
#          Colin's project can be found at <http://evaryont.github.com/arson>
#
#          Contributors: elij <http://monkeyvschicken.net>
#                        MrElendig
#
# CREATED:  2008-08-22 18:41
# MODIFIED: 2009-10-06 12:12

VERSION = '2.5.5'

import glob
import os
import re
import sys
import gzip
import urllib
import urllib2
import subprocess

from getpass import getpass
from distutils import version as Version
from optparse import OptionParser
from cStringIO import StringIO
from tarfile import TarFile

try:
    import cjson as Json
except ImportError:
    import json as Json

try:
    import pycurl
except ImportError:
    __doc__ = """Usage: slurpy [options] <operation> PACKAGE [PACKAGE2..]

 Operations:
  -d, --download          download PACKAGE(s)
                             if passed twice will also download dependencies
                             from the AUR
  -i, --info              show info for PACKAGE(s)
  -s, --search            search for PACKAGE(s)
  -u, --update            check explicitly installed packages for available
                          updates
                             if passed with --download flag(s), perform download
                             operation for each package with an available update

 General options:
  -c, --color             use colored output
  -f, --force             overwrite existing files when dowloading
  -q, --quiet             show only package names in search/update results
  -t DIR, --save-to=DIR   target directory where files will be downloaded
  -v, --verbose           show info messages
                             if passed twice will also show debug messages

  -h, --help              show this message
      --version           show version information"""
else:
    __doc__ = """Usage: slurpy [options] [--sync] <operation> PACKAGE [PACKAGE2..] 
       slurpy [options] --push FILE1 [FILE2..] 

 Modes:
  -S, --sync              Retrieve package(s)/info from the AUR (DEFAULT)
  -P, --push              Upload a package to the AUR

 Sync Operations:              
  -d, --download          download PACKAGE(s)
                             if passed twice will also download dependencies
                             from the AUR
  -i, --info              show info for PACKAGE(s)
  -s, --search            search for PACKAGE(s)
  -u, --update            check explicitly installed packages for available
                          updates 
                             if passed with --download flag(s), perform download
                             operation for each package with an available update

 Push Options:
  -C, --category          package category in the AUR
                             New Package DEFAULT: none
                             Update DEFAULT: current category in the AUR
  -U, --user              AUR username
      --cookie-file       file to store AUR session information in

 General options:
  -c, --color             use colored output
  -f, --force             overwrite existing files when dowloading
  -q, --quiet             show only package names in search/update results
  -t DIR, --save-to=DIR   target directory where files will be downloaded
  -v, --verbose           show info messages
                             if passed twice will also show debug messages

  -h, --help              show this message
      --version           show version information"""

# utility functions
def json_decode(url):
    """Open <url> and decode the json response"""
    request = urllib2.Request(url)
    request.add_header("Accept-encoding", "gzip")
    request.add_header("User-agent", "slurpy/%s" % VERSION)
    try:
        usock = urllib2.urlopen(request)
        data = usock.read()
        if usock.headers.get('content-encoding', None) == 'gzip':
            data = gzip.GzipFile(fileobj=StringIO(data)).read()
        usock.close()
    except:
        ## just rethrow for now
        raise
    finally:
        # clean up
        del request
        del usock
    try:
        return Json.decode(data)
    except AttributeError:
        return Json.loads(data)

def read_config():
    """Read in the slurpy runtime config to set default options."""
    home = os.getenv('HOME')
    xdg_config_home = os.getenv('XDG_CONFIG_HOME')

    # configuration options, sane defaults
    AUR_USER = None
    COOKIE_FILE = "~/.slurpy.aurcookie"
    TARGET_DIR = "."
    USE_COLOR = False
    VERBOSE = 0
    
    conf = None
    if os.path.exists(xdg_config_home + "/slurpy/slurpyrc"):
        conf = open(xdg_config_home + "/slurpy/slurpyrc")
    elif os.path.exists(home + "/.slurpyrc"):
        conf = open(home + "/.slurpyrc")

    if conf is not None:
        try:
            exec(conf.read())
        except SyntaxError:
            print "error: There is a syntax error in your config file."
            print "Please correct this and try again."
            sys.exit(1)

    return {
            'color': USE_COLOR,
            'cookie_file': COOKIE_FILE,
            'target_dir': os.path.expanduser(TARGET_DIR),
            'user': AUR_USER,
            'verbose': VERBOSE,
            }

def strip_slashes(str):
    """Remove extraneous backslashes (\) from <str>"""
    if str is None:
        return "None"
    str = str.encode('UTF-8')
    if 'cjson' in sys.modules:
        return str.replace('\/', '/')
    return str

# class definitions
class Slurpy():
    
    """Main Slurpy class"""

    COLOR_CONF = "/etc/pacman.d/color.conf"
    AUR_URL = "http://aur.archlinux.org"

    def __init__(self, opts):
        """Sets up colors and sets opts for the class"""
        self.opts = opts

        # default colors to be used if COLOR_CONF is not readable
        self.colors = {"red":"boldred", "green":"boldgreen",
                       "yellow":"boldyellow", "blue":"boldblue",
                       "magenta":"boldmagenta", "cyan":"boldcyan",
                       "white":"boldwhite"}

        # read COLOR_CONF to get pacman-color's settings
        if self.opts.color:
            try:
                fd = open(self.COLOR_CONF, 'r')
                conf = fd.read()
                fd.close()
                for color in self.colors:
                    col = re.findall("^\s*"+color.capitalize()+".*", conf, re.M) 
                    if len(col):
                        col = col[0].split('=')[1].strip()
                        col = re.sub("intensive\s*", "bold", col)
                        self.colors[color] = col
            except IOError:
                self.out(":debug:Error reading color.conf, using default colors")
            

    def out(self, s):
        colors = {"black":      "0",  "gray":           "9",
                  "red":        "1",  "boldred":        "10",
                  "green":      "2",  "boldgreen":      "11",
                  "yellow":     "3",  "boldyellow":     "12",
                  "blue":       "4",  "boldblue":       "13",
                  "magenta":    "5",  "boldmagenta":    "14",
                  "cyan":       "6",  "boldcyan":       "15",
                  "white":      "7",  "boldwhite":      "16",
                  "foreground": "8",  "boldforeground": "17"}

        if self.opts.color:
            # use the template :format: to add color and/or message type
            for k, v in self.colors.items():
                if int(colors[v]) < 9:
                    s = s.replace(':%s:' % k, '\033[3%sm' % colors[v])
                else:
                    v = int(colors[v]) - 9
                    s = s.replace(':%s:' % k, '\033[1;3%sm' % v)

            s = s.replace(':fg:', '\033[1;m')
            s = s.replace(':error:', '\033[31merror:\033[1;m ')
            s = s.replace(':warning:', '\033[33mwarning:\033[1;m ')
            s = s.replace(':info:', '\033[35minfo:\033[1;m ')
            s = s.replace(':debug:', '\033[1;36mdebug:\033[1;m ')
        else:
            # just strip out the template crap
            for k, v in self.colors.items():
                if int(colors[v]) < 9:
                    s = s.replace(':%s:' % k, '')
                else:
                    v = int(colors[v]) - 9
                    s = s.replace(':%s:' % k, '')

            s = s.replace(':fg:', '')
            s = s.replace(':error:', 'error: ')
            s = s.replace(':warning:', 'warning: ')
            s = s.replace(':info:', 'info: ')
            s = s.replace(':debug:', 'debug: ')

        print "\033[1;m%s\033[1;m" % s

class AURSync(Slurpy):

    """ Handles all pull requests from the AUR """

    PACMAN_CACHE = "/var/lib/pacman/local"
    PACMAN_CONF = "/etc/pacman.conf"
    PACMAN_REPOS = ['core', 'extra', 'community']
    PACMAN_SYNC = "/var/lib/pacman/sync/"

    INFO_URL = "http://aur.archlinux.org/rpc.php?type=info&arg="
    SEARCH_URL = "http://aur.archlinux.org/rpc.php?type=search&arg="

    # json constants
    ID = "ID"
    NAME = "Name"
    VERSION = "Version"
    CATEGORY = "CategoryID"
    DESCRIPTION = "Description"
    LOCATION = "LocationID"
    URL = "URL"
    PATH = "URLPath"
    LICENSE = "License"
    VOTES = "NumVotes"
    OUT_OF_DATE = "OutOfDate"
    CATEGORIES = [None, None, "daemons", "devel", "editors", "emulators",
                  "games", "gnome", "i18n", "kde", "lib", "modules",
                  "multimedia", "network", "office", "science", "system",
                  "x11", "xfce", "kernels"]


    def __init__(self, opts, args):

        Slurpy.__init__(self, opts)

        self.args = []
        
        # encode white space
        for arg in args:
            self.args.append(arg.replace(" ", "%20"))

        # enable testing repo if enabled on the machine
        try:
            fd = open(self.PACMAN_CONF, 'r')
            conf = fd.read()
            fd.close()
        except IOError:
            self.out(":info:Error reading pacman.conf, testing repo will" 
                     "remain disabled")

        if re.search('^\s*\[testing\]', conf, re.M):
            self.PACMAN_REPOS = ['testing'] + self.PACMAN_REPOS
            self.out(":debug:Testing repo enabled")

    def display_result(self, pkgs, deps):
        """Print a nicely formated result of <pkgs> and <deps>"""
        if pkgs:
            if len(pkgs) == 1 and not deps:
                out = ":white:%s :fg:downloaded to :green:%s" \
                        % (pkgs[0], os.getcwd())
                self.out(out)
            else:
                self.out("Packages downloaded to :green:%s:" % os.getcwd())
                for pkg in pkgs:
                    self.out("   :white:%s" % pkg)
        if deps:
            if len(deps) == 1 and not pkgs:
                out = ":white:%s :fg:is available in " % deps[0]
                out += ":yellow:pacman repos"
                self.out(out)
            else:
                self.out("\nDependencies found in :yellow:pacman repos:")
                for dep in deps:
                    self.out("   :white:%s" % dep)

    def download(self, ignore=[]):
        """Downloads all packages in <self.args>
        
        Returns any (make)dependencies of that package found in the PKGBUILD.
        """
        dledpkgs = [] # holds list of downloaded pkgs
        repodeps = [] # holds list of dependencies available in pacman repos
        for arg in self.args:
            if arg in ignore: 
                continue

            if self.in_sync_db(arg) != False:
                repodeps.append(arg)
                continue

            json = json_decode(self.INFO_URL + arg)

            if json['type'] == 'error':
                self.out(":error:%s %s" % (arg, json['results']))
                return(dledpkgs, repodeps)

            pkg = json['results']
            url = self.AUR_URL + strip_slashes(pkg[self.PATH])
            c_url = self.AUR_URL + '/packages/' + arg + '/' + arg + '.tar.gz'
            if url != c_url:
                out = ":info:There might be a problem with this package in "
                out += "the AUR's database."
                self.out(out)
                self.out(":info:Using constructed url instead.")
                url = c_url

            fname = url.split('/')[-1].split('.tar.gz')[0]
            if not self.opts.force:
                if os.path.exists(fname + '.tar.gz'):
                    self.out(":error:%s/%s.tar.gz exists" 
                                % (os.getcwd(), fname))
                    self.out("Pass -f to force this operation.")
                    sys.exit(1)

                if os.path.exists(fname):
                    self.out(":error:%s/%s exists" % (os.getcwd(), fname))
                    self.out("Pass -f to force this operation.")
                    sys.exit(1)

            # download .tar.gz
            fd = open(fname + '.tar.gz', 'w')
            fd.write(urllib.urlopen(url).read())
            fd.close()

            # unzip -- per aur guidelines, all fnames must be .tar.gz'd
            try:
                fd = TarFile.open(fname + '.tar.gz', 'r:gz')
                fd.extractall()
                fd.close()
            except: 
                self.out(":error:Error extracting archive %s.tar.gz" % fname)
                os.unlink(fname + '.tar.gz')
                sys.exit(1)

            os.unlink(fname + '.tar.gz')
            dledpkgs.append(fname)
            
            # download deps
            if self.opts.download > 1:
                fd = open(fname + '/PKGBUILD', 'r')
                pkgb = fd.read()
                fd.close()

                deps = []
                deptup = re.findall('[^(opt)](make)?depends=\((.*?)\)', 
                                    pkgb, re.S)
                for group in deptup:
                    for dep in group[1].split():
                        dep = re.findall('(.[^<>=]*).*', dep)[0].strip("'")
                        deps.append(dep)

                # download dependencies, but ignore already downloaded pkgs
                pkgs, deps = AURSync(self.opts, deps).download(dledpkgs)

                if pkgs != []:
                    dledpkgs.extend(pkgs)
                if deps != []:
                    repodeps.extend(deps)

        # remove dups
        repodeps = list(set(repodeps))
        repodeps.sort()
        dledpkgs.sort()

        return dledpkgs, repodeps

    def in_sync_db(self, name): 
        """Checks if <name> exists in the local syncdb for <repo>

        Returns true if found, otherwise false
        """
        for repo in self.PACMAN_REPOS:
            syncd = self.PACMAN_SYNC + repo
            if glob.glob(syncd + "/" + name + "-*"):
                return repo
        return False

    def info(self):
        """Prints all known info about each package in <self.args>"""
        for arg in self.args:
            json = json_decode(self.INFO_URL + arg)
            if json['type'] == 'error':
                self.out(":error:%s" % json['results'])
                sys.exit(1)
            pkg = json['results']

            if pkg[self.OUT_OF_DATE] == '0':
                out_of_date = "No"
            else:
                out_of_date = "Yes"

            self.out("Repository      : :magenta:aur")
            self.out("Name            : :white:%s" % pkg[self.NAME])
            if out_of_date == "Yes":
                out = ":red:%s" % pkg[self.VERSION]
            else:
                out = ":green:%s" % pkg[self.VERSION]
            self.out("Version         : %s" % out)
            self.out("URL             : :cyan:%s" 
                        % strip_slashes(pkg[self.URL]))
            self.out("AUR Page        : :cyan:%s/packages.php?ID=%s" 
                        % (self.AUR_URL, pkg[self.ID]))
            self.out("Category        : %s" 
                        % self.CATEGORIES[int(pkg[self.CATEGORY])])
            self.out("Licenses        : %s" 
                        % strip_slashes(pkg[self.LICENSE]))
            self.out("Number of Votes : %s" % pkg[self.VOTES])
            if out_of_date == "Yes":
                out = ":red:%s" % out_of_date
            else:
                out = ":green:%s" % out_of_date
            self.out("Out of Date     : %s" % out)
            self.out("Description     : %s\n" 
                        % strip_slashes(pkg[self.DESCRIPTION]))

    def run(self):
        """Main processing for AURSync.

        Handles all function dispatching and pre/post result output.
        """
        if self.opts.update and self.opts.download:
            updates = [] # holds all available updates

            try:
                if self.opts.target_dir is not None:
                    os.chdir(self.opts.target_dir)
            except OSError:
                self.out(":error:%s does not exist or is not a directory"
                            % self.opts.target_dir)
                sys.exit(1)

            for pkg, version in self.update():
                updates.append(pkg) 

            if updates == []:
                self.out("No updates available")
                return

            self.args = updates
            self.out(":info:Downloading updates...")

            self.display_result(*self.download())

        elif self.opts.download:
            try:
                if self.opts.target_dir is not None:
                    os.chdir(self.opts.target_dir)
            except OSError:
                self.out(":error:%s does not exist or is not a directory"
                            % self.opts.target_dir)
                sys.exit(1)

            self.display_result(*self.download())

        elif self.opts.info:
            self.info()
        elif self.opts.search:
            self.search()
        elif self.opts.update:
            for pkg, version in self.update():
                if self.opts.quiet:
                    self.out(pkg)
                elif not self.opts.download:
                    self.out(":white:%s :green:%s" % (pkg, version))
        else:
            self.out(__doc__)

    def search(self):
        """Search the AUR for <self.args> and print results to the screen"""
        pkgs = []
        for arg in self.args:
            filter = None
            # user passed a filter argument
            if arg[0] == '^' or arg[-1] == '$':
                filter = re.compile(arg)
                arg = arg.strip("^$")

            json = json_decode(self.SEARCH_URL + arg)
            if json['type'] == 'error':
                if json['results'].lower() != "no results found":
                    self.out(":error:%s" % json['results'])
            else:
                if filter is None:
                    pkgs.extend(json['results'])
                    continue
                for pkg in json['results']:
                        if filter.search(pkg[self.NAME]):
                            pkgs.append(pkg)

        if pkgs == []:
            return

        # sort
        spkgs = sorted(pkgs, key=lambda k: k[self.NAME])
        del pkgs

        # remove dups -- note: extra list traversal, but imo it's worth it
        i = 0
        for pkg in spkgs:
            if pkg == spkgs[i]: 
                continue
            i += 1
            spkgs[i] = pkg
        del spkgs[i+1:]

        for pkg in spkgs:
            if self.opts.quiet:
                self.out(":white:%s" % pkg[self.NAME])
            else:
                out = ":magenta:aur:fg:/:white:%s " % pkg[self.NAME]
                if pkg[self.OUT_OF_DATE] == '0':
                    out += ":green:%s" % pkg[self.VERSION]
                else:
                    out += ":red:%s" % pkg[self.VERSION]
                self.out(out)
                self.out("    %s" % strip_slashes(pkg[self.DESCRIPTION]))

    def update(self):
        """Checks all explicitly installed packages for updates in the AUR"""
        updates = []

        if not self.opts.quiet:
            self.out(":info:Checking for package updates... ")

        fd = subprocess.Popen(["pacman", "-Qm"], stdout=subprocess.PIPE).stdout
        for ln in fd.readlines():
            name, version = ln[:-1].split(' ')
            pkg = json_decode(self.INFO_URL + name)['results']
            if pkg != "No result found":
                if self.update_available(pkg['Name'], pkg['Version']):
                    updates.append((name, pkg['Version']))

        return updates

    def update_available(self, name, version):
        """Helper for update(): does version comparison logic 
        
        Returns true if a new version is available, otherwise false
        """
        # check that the version is not negative. $pkgver should -never- be
        # negative but this happens when the $pkgver in the PKGBUILD is derived
        # from some bash magic that the AUR doesn't understand.
        if version[0] == '-':
            out = ":warning:AUR returned a negative version number for "
            out += ":white:%s. Ignoring" % name
            self.out(out)
            return False

        # if the specific package/version is in the cache, there must not be an
        # update
        if os.path.exists(self.PACMAN_CACHE + "/" + name + "-" + version):
            return False
        else:
            glb = glob.glob(self.PACMAN_CACHE + "/" + name + "-*")

        if glb:
            # make sure we have the right one then compare
            for p in glb:
                n, v, r = os.path.basename(p).rsplit('-', 2) # foo-bar-1.2.3-2  
                if n == name:
                    inst_ver = '-'.join((v, r))
                    inst_ver = Version.LooseVersion(inst_ver)
                    new_ver = Version.LooseVersion(version)

                    if new_ver > inst_ver:
                        return True
                    return False

        # We failed to find 'name' in the pacman db. Let's inform the user.
        out = ":warning:Could not find ':white:%s:" % name
        out = "fg' in the pacman db.  Ignoring"
        self.out(out)
        return False

class AURPush(Slurpy):
    
    """ Handles all push requests to the AUR """

    AUR_SUBMIT_URL = "http://aur.archlinux.org/pkgsubmit.php"

    def __init__(self, opts, args):
        Slurpy.__init__(self, opts)

        self.args = args
        self.buffer = StringIO()

        self.curl = pycurl.Curl()
        self.curl.setopt(pycurl.HTTPHEADER, ["Expect:"])
        self.curl.setopt(pycurl.COOKIEJAR, self.opts.cookie_file)
        self.curl.setopt(pycurl.WRITEFUNCTION, self.buffer.write)
        self.curl.setopt(pycurl.FOLLOWLOCATION, 1)

    def __del__(self):
        """ Clean up curl and cookie file """
        self.curl.close()
        if os.path.exists(self.opts.cookie_file):
            os.unlink(self.opts.cookie_file)

    def login(self):
        """ Log in to the AUR web interface with self.opts.user,
        prompt for password.
        """
        if self.opts.user is None:
            self.opts.user = raw_input('User: ')

        self.opts.password = getpass('Password: ')
        data = [
            ('user', self.opts.user),
            ('passwd', self.opts.password)]

        self.curl.setopt(pycurl.HTTPPOST, data)
        self.curl.setopt(pycurl.URL, self.AUR_URL)
        self.curl.perform()
        
        # Bad username or password
        if self.buffer.getvalue().find("Bad username or password") != -1:
            self.out(":error:Bad username or password. Please try again.") 
            sys.exit(1)

    def run(self):
        """ Main processing for AURPush """
        if opts.category is not None:
            if opts.category not in AURSync.CATEGORIES:
                self.out(":error:Category does not exist, please enter one of "
                              "the following categories:")
                for cat in AURSync.CATEGORIES[2:]:
                    self.out(cat)

                sys.exit(1)

        self.login()
        self.upload()

    def upload(self):
        """ Upload files in self.args to the aur """

        for arg in self.args:
            if not os.path.isfile(arg):
                self.out(":error:%s does not exist or is not a file." % arg)
                sys.exit(1)

            data = [
                ('pkgsubmit', '1'),
                ('category', '%s' % AURSync.CATEGORIES.index(self.opts.category)),
                ('pfile', (pycurl.FORM_FILE, arg))]

            self.curl.setopt(pycurl.HTTPPOST, data)
            self.curl.setopt(pycurl.URL, self.AUR_SUBMIT_URL)

            self.buffer.truncate(0)
            try:
                self.curl.perform()
            except:
                self.out(":error:Something is wrong with the selected file.")
                self.out("If it is a .tar.gz file, try rebuilding it.")

            if self.buffer.getvalue().find("not allowed to overwrite") != -1:
                out = ":error::white:%s does not own this " % self.opts.user
                out += "package and can not overwrite these files."
                self.out(out)
            elif self.buffer.getvalue().find("Unknown file format") != -1:
                self.out(":error:Incorrect file format. Upload must conform "
                         "to AUR packaging guidelines.")

            idx = self.buffer.getvalue().find("<span class='f2'>")
            if idx != -1:
                pkg = self.buffer.getvalue()[17+idx:]

                idx = pkg.find("</span>")
                if idx != -1:
                    pkg = pkg[:idx]
                    
                    if pkg is not None:
                        self.out(":white:%s :fg:has been uploaded."
                                    % pkg)
            

# main processing 
if __name__ == '__main__':

    conf = read_config()

    _version = ' '.join(("%prog",VERSION))
    parser = OptionParser(version=_version, conflict_handler="resolve")
    parser.add_option('-d', '--download', action='count')
    parser.add_option('-c', '--color', action='store_true',
                            default=conf['color'])
    parser.add_option('-f', '--force', action='store_true')
    parser.add_option('-h', '--help', action='store_true')
    parser.add_option('-i', '--info', action='store_true')
    parser.add_option('-q', '--quiet', action='store_true')
    parser.add_option('-s', '--search', action='store_true')
    parser.add_option('-t', '--save-to', dest='target_dir', action='store',
                            default=conf['target_dir'])
    parser.add_option('-u', '--update', action='store_true')
    parser.add_option('-v', '--verbose', action='count',
                            default=conf['verbose'])
    parser.add_option('-S', '--sync', action='store_true', default=True)

    if 'pycurl' in sys.modules:
        parser.add_option('-C', '--category', action='store', default=None)
        parser.add_option('-P', '--push', action='store_true', default=False)
        parser.add_option('-U', '--user', action='store', default=conf['user'])
        parser.add_option('', '--cookie-file', action='store',
                              default=conf['cookie_file'])

    opts, args = parser.parse_args()

    if 'pycurl' in sys.modules and opts.push:
        AURPush(opts, args).run()
    else:
        AURSync(opts, args).run()

# vim:sw=4:ts=4:sts=4:
